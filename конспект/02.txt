Так как просто смена значения в компоненте не делает перерисовку компонента, мы должны предупредить react об этом. Для этого было создано состояние компонента, которое содержит какие либо данные изначально. При изменении состояния компонента, react сранивает старое и новое состояние, и потом на основе сравнения, отрисовывает новые данные в компоненте

Хук useState принимает значение по умолчанию, в данном случае 0. Хук возвращает массив из двух элементов, первый элемент это значение которое мы передали в хук, а второй элемент это функция которая меняет значение. Мы не можем на прямую перезаписывать переменную с данными, поэтому используем функцию для смены значения.

С помощью деструктуризации мы объявляем две переменные
likes - переменная со значением
setLikes - функция которая принимает данные и устанавливает их в likes
seState(0) - хук со значением по умолчанию
const [likes, setLikes] = useState(0);

Вызываем функцию setLikes и устанавливаем новое значение
setLikes(likes + 1);


Для вызова каких либо функций через событие onClick, мы передаем только название функции, без скобок. После нажатия на кнопку, будет вызвана функция. Если оставить круглые скобки, то функция будет вызвана сразу.

Функция будет вызвана после клика на кнопку
<button onClick={increment}>Increment</button>

Функция будет вызвана сразу же
<button onClick={increment()}>Increment</button>

Функция будет вызвана после нажатия на кнопку, так как мы обернули ее в анонимную стрелочную функцию
<button onClick={() => increment()}>Increment</button>

Каждый компонент должен содержать один корневой элемент, в данном случае div



import React, { useState } from 'react';

const App = () => {
  const [likes, setLikes] = useState(0);

  function increment() {
    setLikes(likes + 1);
  }

  function decrement() {
    setLikes(likes - 1);
  }

  return (
    <div className='App'>
      <h1>{likes}</h1>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </div>
  );
};

export default App;

